<!DOCTYPE html>
<html lang="en"><head><meta charset="UTF-8"/><meta name="viewport" content="width=device-width, initial-scale=1.0"/><title>Main functions · UtilitiesForMRI.jl</title><script data-outdated-warner src="../assets/warner.js"></script><link href="https://cdnjs.cloudflare.com/ajax/libs/lato-font/3.0.0/css/lato-font.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/juliamono/0.045/juliamono.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/5.15.4/css/fontawesome.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/5.15.4/css/solid.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/5.15.4/css/brands.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/KaTeX/0.13.24/katex.min.css" rel="stylesheet" type="text/css"/><script>documenterBaseURL=".."</script><script src="https://cdnjs.cloudflare.com/ajax/libs/require.js/2.3.6/require.min.js" data-main="../assets/documenter.js"></script><script src="../siteinfo.js"></script><script src="../../versions.js"></script><link class="docs-theme-link" rel="stylesheet" type="text/css" href="../assets/themes/documenter-dark.css" data-theme-name="documenter-dark" data-theme-primary-dark/><link class="docs-theme-link" rel="stylesheet" type="text/css" href="../assets/themes/documenter-light.css" data-theme-name="documenter-light" data-theme-primary/><script src="../assets/themeswap.js"></script></head><body><div id="documenter"><nav class="docs-sidebar"><div class="docs-package-name"><span class="docs-autofit"><a href="../">UtilitiesForMRI.jl</a></span></div><form class="docs-search" action="../search/"><input class="docs-search-query" id="documenter-search-query" name="q" type="text" placeholder="Search docs"/></form><ul class="docs-menu"><li><a class="tocitem" href="../">Introduction</a></li><li><a class="tocitem" href="../installation/">Installation</a></li><li><a class="tocitem" href="../examples/">Getting started</a></li><li class="is-active"><a class="tocitem" href>Main functions</a><ul class="internal"><li><a class="tocitem" href="#Spatial-geometry-utilities"><span>Spatial geometry utilities</span></a></li><li><a class="tocitem" href="#k-space-geometry-utilities"><span><span>$k$</span>-space geometry utilities</span></a></li><li><a class="tocitem" href="#Fourier-transform-utilities"><span>Fourier-transform utilities</span></a></li><li><a class="tocitem" href="#Resampling-utilities"><span>Resampling utilities</span></a></li><li><a class="tocitem" href="#Image-quality-metrics"><span>Image-quality metrics</span></a></li><li><a class="tocitem" href="#Visualization-tools"><span>Visualization tools</span></a></li></ul></li></ul><div class="docs-version-selector field has-addons"><div class="control"><span class="docs-label button is-static is-size-7">Version</span></div><div class="docs-selector control is-expanded"><div class="select is-fullwidth is-size-7"><select id="documenter-version-selector"></select></div></div></div></nav><div class="docs-main"><header class="docs-navbar"><nav class="breadcrumb"><ul class="is-hidden-mobile"><li class="is-active"><a href>Main functions</a></li></ul><ul class="is-hidden-tablet"><li class="is-active"><a href>Main functions</a></li></ul></nav><div class="docs-right"><a class="docs-edit-link" href="https://github.com/grizzuti/UtilitiesForMRI/blob/main/docs/src/functions.md" title="Edit on GitHub"><span class="docs-icon fab"></span><span class="docs-label is-hidden-touch">Edit on GitHub</span></a><a class="docs-settings-button fas fa-cog" id="documenter-settings-button" href="#" title="Settings"></a><a class="docs-sidebar-button fa fa-bars is-hidden-desktop" id="documenter-sidebar-button" href="#"></a></div></header><article class="content" id="documenter-page"><h1 id="Main-functions"><a class="docs-heading-anchor" href="#Main-functions">Main functions</a><a id="Main-functions-1"></a><a class="docs-heading-anchor-permalink" href="#Main-functions" title="Permalink"></a></h1><h2 id="Spatial-geometry-utilities"><a class="docs-heading-anchor" href="#Spatial-geometry-utilities">Spatial geometry utilities</a><a id="Spatial-geometry-utilities-1"></a><a class="docs-heading-anchor-permalink" href="#Spatial-geometry-utilities" title="Permalink"></a></h2><p>These are the main utilities to build spatial discretization objects.</p><article class="docstring"><header><a class="docstring-binding" id="UtilitiesForMRI.spatial_geometry-Union{Tuple{T}, Tuple{Tuple{T, T, T}, Tuple{Integer, Integer, Integer}}} where T&lt;:Real" href="#UtilitiesForMRI.spatial_geometry-Union{Tuple{T}, Tuple{Tuple{T, T, T}, Tuple{Integer, Integer, Integer}}} where T&lt;:Real"><code>UtilitiesForMRI.spatial_geometry</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">spatial_geometry(field_of_view::NTuple{3,T}, nsamples::NTuple{3,Integer};
                 origin::NTuple{3,T}=field_of_view./2) where {T&lt;:Real}</code></pre><p>Return a 3D spatial geometry object that summarizes a Cartesian spatial discretization. Must specify domain size and number of samples per dimension. The origin of the domain can be changed by setting the keyword <code>origin</code>.</p><p>Example:</p><pre><code class="language-julia hljs">X = spatial_geometry((1f0, 1f0, 1f0), (64, 64, 64); origin=(0f0, 0f0, 0f0))</code></pre></div></section></article><h2 id="k-space-geometry-utilities"><a class="docs-heading-anchor" href="#k-space-geometry-utilities"><span>$k$</span>-space geometry utilities</a><a id="k-space-geometry-utilities-1"></a><a class="docs-heading-anchor-permalink" href="#k-space-geometry-utilities" title="Permalink"></a></h2><p>These are the main utilities to specify <span>$k$</span>-space acquisition trajectories, where the ordering is typically dictated by the order of acquisition (e.g., a proxy for time).</p><article class="docstring"><header><a class="docstring-binding" id="UtilitiesForMRI.kspace_sampling-Union{Tuple{T}, Tuple{Tuple{Integer, Integer, Integer}, AbstractMatrix{T}, AbstractVector{T}}} where T&lt;:Real" href="#UtilitiesForMRI.kspace_sampling-Union{Tuple{T}, Tuple{Tuple{Integer, Integer, Integer}, AbstractMatrix{T}, AbstractVector{T}}} where T&lt;:Real"><code>UtilitiesForMRI.kspace_sampling</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">kspace_sampling(permutation_dims::NTuple{3,Integer},
                coord_phase_encoding::AbstractArray{T,2},
                coord_readout::AbstractVector{T}) where {T&lt;:Real}</code></pre><p>Returns a 3D <span>$k$</span>-space trajectory that is (time-wise) ordered by phase-encoding plane coordinates. The plane is orthogonal to a specific coordinate direction (e.g. <span>$x$</span>, <span>$y$</span>, or <span>$z$</span>). The input <code>permutation_dims</code> specifies the phase-encoding plane dimensions (in this order) and readout dimension. The <code>coord_phase_encoding</code> should be an array of size <span>$n_t\times 3$</span> and represents the phase-encoding plane coordinate. Similarly, the readout coordinate <code>coord_readout</code> should be an array of size <span>$n_k$</span>.</p></div></section></article><article class="docstring"><header><a class="docstring-binding" id="UtilitiesForMRI.kspace_sampling-Union{Tuple{T}, Tuple{CartesianSpatialGeometry{T}, Tuple{Integer, Integer}}} where T&lt;:Real" href="#UtilitiesForMRI.kspace_sampling-Union{Tuple{T}, Tuple{CartesianSpatialGeometry{T}, Tuple{Integer, Integer}}} where T&lt;:Real"><code>UtilitiesForMRI.kspace_sampling</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">kspace_sampling(X::CartesianSpatialGeometry{T},
                phase_encoding_dims::NTuple{2,Integer};
                phase_encode_sampling::Union{Nothing,AbstractVector{&lt;:Integer}}=nothing,
                readout_sampling::Union{Nothing,AbstractVector{&lt;:Integer}}=nothing) where {T&lt;:Real}</code></pre><p>Returns a 3D Cartesian <span>$k$</span>-space trajectory that is (time-wise) ordered by phase-encoding plane coordinates. The plane is orthogonal to a specific coordinate direction (e.g. <span>$x$</span>, <span>$y$</span>, or <span>$z$</span>). The spatial discretization is determined by the <code>CartesianSpatialGeometry</code> object <code>X</code>. The <code>phase_encoding_dims</code> indicate the phase-encoding plane dimensions. Subsampling of the full Cartesian <code>k</code>-space is obtained with the optional keyword inputs <code>phase_encode_sampling</code> and <code>readout_sampling</code>.</p></div></section></article><h2 id="Fourier-transform-utilities"><a class="docs-heading-anchor" href="#Fourier-transform-utilities">Fourier-transform utilities</a><a id="Fourier-transform-utilities-1"></a><a class="docs-heading-anchor-permalink" href="#Fourier-transform-utilities" title="Permalink"></a></h2><p>In order to manipulate the non-uniform Fourier operator based on rigid-motion perturbation, see Section <a href="../examples/#Getting-started">Getting started</a> . </p><article class="docstring"><header><a class="docstring-binding" id="UtilitiesForMRI.nfft_linop-Union{Tuple{T}, Tuple{CartesianSpatialGeometry{T}, UtilitiesForMRI.AbstractStructuredKSpaceSampling{T}}} where T&lt;:Real" href="#UtilitiesForMRI.nfft_linop-Union{Tuple{T}, Tuple{CartesianSpatialGeometry{T}, UtilitiesForMRI.AbstractStructuredKSpaceSampling{T}}} where T&lt;:Real"><code>UtilitiesForMRI.nfft_linop</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">nfft_linop(X::CartesianSpatialGeometry, K::StructuredKSpaceSampling)</code></pre><p>Return the non-uniform Fourier transform as a linear operator for a specified Cartesian spatial discretization <code>X</code> and a <span>$k$</span>-space trajectory <code>K</code>.</p><p><strong>Example</strong></p><pre><code class="language-julia hljs">X = spatial_geometry((1f0, 1f0, 1f0), (32, 32, 32))
K = kspace_sampling(X, (1, 2))
F = nfft_linop(X, K)
u = randn(ComplexF32, X.nsamples)
d = F*u  # evaluation
    F&#39;*d # adjoint</code></pre></div></section></article><h2 id="Resampling-utilities"><a class="docs-heading-anchor" href="#Resampling-utilities">Resampling utilities</a><a id="Resampling-utilities-1"></a><a class="docs-heading-anchor-permalink" href="#Resampling-utilities" title="Permalink"></a></h2><p>We list the main functionalities for subsampling/upsampling of spatial geometries, <span>$k$</span>-space geometries, and 3D images:</p><article class="docstring"><header><a class="docstring-binding" id="UtilitiesForMRI.resample-Tuple{CartesianSpatialGeometry, Tuple{Integer, Integer, Integer}}" href="#UtilitiesForMRI.resample-Tuple{CartesianSpatialGeometry, Tuple{Integer, Integer, Integer}}"><code>UtilitiesForMRI.resample</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">resample(X::CartesianSpatialGeometry, n::NTuple{3,Integer})</code></pre><p>Up/down-sampling of Cartesian discretization geometry. The field of view and origin of <code>X</code> are kept the same, while the sampling is changed according to <code>n</code>.</p></div></section></article><article class="docstring"><header><a class="docstring-binding" id="UtilitiesForMRI.subsample-Union{Tuple{T}, Tuple{UtilitiesForMRI.AbstractStructuredKSpaceSampling{T}, Union{Tuple{T, T, T}, T}}} where T&lt;:Real" href="#UtilitiesForMRI.subsample-Union{Tuple{T}, Tuple{UtilitiesForMRI.AbstractStructuredKSpaceSampling{T}, Union{Tuple{T, T, T}, T}}} where T&lt;:Real"><code>UtilitiesForMRI.subsample</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">subsample(K, k_max::Union{T,NTuple{3,T}}; radial::Bool=false)</code></pre><p>Down-sampling of a <span>$k$</span>-space trajectory. The output is a subset of the original <span>$k$</span>-space trajectory such that the <span>$k$</span>-space coordinates <span>$(k_1,k_2,k_3)$</span> are:     - <span>$k_i\le k_{\mathrm{max},i}$</span> (if <code>radial=false</code>), or     - <span>$||\mathbf{k}||\le k_{\mathrm{max}}$</span> (if <code>radial=true</code>). The ordering of the subsampled trajectory is inherited from the original trajectory.</p></div></section></article><article class="docstring"><header><a class="docstring-binding" id="UtilitiesForMRI.subsample-Union{Tuple{T}, Tuple{UtilitiesForMRI.AbstractStructuredKSpaceSampling{T}, CartesianSpatialGeometry{T}}} where T&lt;:Real" href="#UtilitiesForMRI.subsample-Union{Tuple{T}, Tuple{UtilitiesForMRI.AbstractStructuredKSpaceSampling{T}, CartesianSpatialGeometry{T}}} where T&lt;:Real"><code>UtilitiesForMRI.subsample</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">subsample(K, X::CartesianSpatialGeometry;
          radial::Bool=false, also_readout::Bool=true)</code></pre><p>Down-sampling of a <span>$k$</span>-space trajectory, similarly to <a href="#UtilitiesForMRI.subsample-Union{Tuple{T}, Tuple{UtilitiesForMRI.AbstractStructuredKSpaceSampling{T}, Union{Tuple{T, T, T}, T}}} where T&lt;:Real"><code>subsample</code></a>. The maximum cutoff frequency is inferred from the Nyquist frequency of a Cartesian spatial geometry <code>X</code>.</p></div></section></article><article class="docstring"><header><a class="docstring-binding" id="UtilitiesForMRI.subsample-Union{Tuple{CT}, Tuple{T}, Tuple{StructuredKSpaceSampling{T}, AbstractMatrix{CT}, SubsampledStructuredKSpaceSampling{T}}} where {T&lt;:Real, CT&lt;:Union{Complex{T}, T}}" href="#UtilitiesForMRI.subsample-Union{Tuple{CT}, Tuple{T}, Tuple{StructuredKSpaceSampling{T}, AbstractMatrix{CT}, SubsampledStructuredKSpaceSampling{T}}} where {T&lt;:Real, CT&lt;:Union{Complex{T}, T}}"><code>UtilitiesForMRI.subsample</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">subsample(K, d::AbstractArray{&lt;:Complex,2}, Kq; norm_constant=nothing)</code></pre><p>Down-sampling of a <span>$k$</span>-space data array <code>d</code> associated to a <span>$k$</span>-space trajectory <code>K</code>, e.g. <code>d_i=d(\mathbf{k}_i)</code>. The output is a subset of the original data array, which is associated to the down-sampled <span>$k$</span>-space <code>Kq</code> (obtained, for example, via <a href="#UtilitiesForMRI.subsample-Union{Tuple{T}, Tuple{UtilitiesForMRI.AbstractStructuredKSpaceSampling{T}, Union{Tuple{T, T, T}, T}}} where T&lt;:Real"><code>subsample</code></a>). The keyword <code>norm_constant</code> allows the rescaling of the down-sampled data.</p></div></section></article><article class="docstring"><header><a class="docstring-binding" id="UtilitiesForMRI.subsample-Union{Tuple{CT}, Tuple{T}, Tuple{CartesianStructuredKSpaceSampling{T}, AbstractMatrix{CT}, SubsampledCartesianStructuredKSpaceSampling{T}}} where {T&lt;:Real, CT&lt;:Union{Complex{T}, T}}" href="#UtilitiesForMRI.subsample-Union{Tuple{CT}, Tuple{T}, Tuple{CartesianStructuredKSpaceSampling{T}, AbstractMatrix{CT}, SubsampledCartesianStructuredKSpaceSampling{T}}} where {T&lt;:Real, CT&lt;:Union{Complex{T}, T}}"><code>UtilitiesForMRI.subsample</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">subsample(K, d::AbstractArray{&lt;:Complex,2}, Kq; norm_constant=nothing)</code></pre><p>Down-sampling of a <span>$k$</span>-space data array <code>d</code> associated to a <span>$k$</span>-space trajectory <code>K</code>, e.g. <code>d_i=d(\mathbf{k}_i)</code>. The output is a subset of the original data array, which is associated to the down-sampled <span>$k$</span>-space <code>Kq</code> (obtained, for example, via <a href="#UtilitiesForMRI.subsample-Union{Tuple{T}, Tuple{UtilitiesForMRI.AbstractStructuredKSpaceSampling{T}, Union{Tuple{T, T, T}, T}}} where T&lt;:Real"><code>subsample</code></a>). The keyword <code>norm_constant</code> allows the rescaling of the down-sampled data.</p></div></section></article><article class="docstring"><header><a class="docstring-binding" id="UtilitiesForMRI.resample-Union{Tuple{CT}, Tuple{T}, Tuple{AbstractArray{CT, 3}, Tuple{Integer, Integer, Integer}}} where {T&lt;:Real, CT&lt;:Union{Complex{T}, T}}" href="#UtilitiesForMRI.resample-Union{Tuple{CT}, Tuple{T}, Tuple{AbstractArray{CT, 3}, Tuple{Integer, Integer, Integer}}} where {T&lt;:Real, CT&lt;:Union{Complex{T}, T}}"><code>UtilitiesForMRI.resample</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">resample(u, n_scale::NTuple{3,Integer}; damping_factor=nothing)</code></pre><p>Resampling of spatial array <code>u</code>. The underlying field of view represented by <code>u</code> is maintained, while the original sampling rate <code>n=size(u)</code> is changed to <code>n_scale</code>.</p></div></section></article><h2 id="Image-quality-metrics"><a class="docs-heading-anchor" href="#Image-quality-metrics">Image-quality metrics</a><a id="Image-quality-metrics-1"></a><a class="docs-heading-anchor-permalink" href="#Image-quality-metrics" title="Permalink"></a></h2><p>Convenience functions to compute slice-based PSNR and SSIM metrics for 3D images (these relies on the package <code>ImageQualityMetrics</code> ):</p><article class="docstring"><header><a class="docstring-binding" id="UtilitiesForMRI.psnr-Union{Tuple{N}, Tuple{T}, Tuple{AbstractArray{T, 3}, AbstractArray{T, 3}}} where {T&lt;:Real, N}" href="#UtilitiesForMRI.psnr-Union{Tuple{N}, Tuple{T}, Tuple{AbstractArray{T, 3}, AbstractArray{T, 3}}} where {T&lt;:Real, N}"><code>UtilitiesForMRI.psnr</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">psnr(u_noisy::AbstractArray{T,3}, u_ref::AbstractArray{T,3};
     slices::Union{Nothing,NTuple{N,VolumeSlice}}=nothing,
     orientation::Orientation=standard_orientation()) where {T&lt;:Real,N}</code></pre><p>Compute 2D power signal-to-noise ratio for the indicated 2D slices of a 3D array. The optional keyword <code>slices</code> indicates the 2D slices in object (see <a href="#UtilitiesForMRI.volume_slice-Tuple{Any, Any}"><code>volume_slice</code></a>), according to the 3D <code>orientation</code> (see <a href="#UtilitiesForMRI.orientation-Tuple{Tuple{Integer, Integer, Integer}}"><code>orientation</code></a>).</p></div></section></article><article class="docstring"><header><a class="docstring-binding" id="UtilitiesForMRI.ssim-Union{Tuple{N}, Tuple{T}, Tuple{AbstractArray{T, 3}, AbstractArray{T, 3}}} where {T&lt;:Real, N}" href="#UtilitiesForMRI.ssim-Union{Tuple{N}, Tuple{T}, Tuple{AbstractArray{T, 3}, AbstractArray{T, 3}}} where {T&lt;:Real, N}"><code>UtilitiesForMRI.ssim</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">ssim(u_noisy::AbstractArray{T,3}, u_ref::AbstractArray{T,3};
     slices::Union{Nothing,NTuple{N,VolumeSlice}}=nothing,
     orientation::Orientation=standard_orientation()) where {T&lt;:Real,N}</code></pre><p>Compute 2D structural similarity index for the indicated 2D slices of a 3D array. The optional keyword <code>slices</code> indicates the 2D slices in object (see <a href="#UtilitiesForMRI.volume_slice-Tuple{Any, Any}"><code>volume_slice</code></a>), according to the 3D <code>orientation</code> (see <a href="#UtilitiesForMRI.orientation-Tuple{Tuple{Integer, Integer, Integer}}"><code>orientation</code></a>).</p></div></section></article><h2 id="Visualization-tools"><a class="docs-heading-anchor" href="#Visualization-tools">Visualization tools</a><a id="Visualization-tools-1"></a><a class="docs-heading-anchor-permalink" href="#Visualization-tools" title="Permalink"></a></h2><article class="docstring"><header><a class="docstring-binding" id="UtilitiesForMRI.orientation-Tuple{Tuple{Integer, Integer, Integer}}" href="#UtilitiesForMRI.orientation-Tuple{Tuple{Integer, Integer, Integer}}"><code>UtilitiesForMRI.orientation</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">orientation(perm::NTuple{3,Integer}; reverse::NTuple{3,Bool}=(false,false,false))</code></pre><p>Defines an orientation for a 3D image. It is mostly useful for standardizing plotting utilities. For example it can be used to reorder a 3D image such that in radiological terms, after reordering:     - 1st dimension = left-right     - 2nd dimension = posterior-anterior     - 3rd dimension = inferior-superior</p><p>The input <code>perm</code> determines an ordering for the 3D dimensions, while the keyword <code>reverse</code> specifies which dimensions are negatively oriented.</p></div></section></article><article class="docstring"><header><a class="docstring-binding" id="UtilitiesForMRI.standard_orientation-Tuple{}" href="#UtilitiesForMRI.standard_orientation-Tuple{}"><code>UtilitiesForMRI.standard_orientation</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">standard_orientation()</code></pre><p>Returns the standard orientation (no reordering).</p></div></section></article><article class="docstring"><header><a class="docstring-binding" id="UtilitiesForMRI.volume_slice-Tuple{Any, Any}" href="#UtilitiesForMRI.volume_slice-Tuple{Any, Any}"><code>UtilitiesForMRI.volume_slice</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">volume_slice(dim::Integer, n::Integer; window=nothing)</code></pre><p>Specifies a 2D slice with respect to a 3D image: <code>dim</code> is the dimension orthogonal to the 2D slice, <code>n</code> is the position of the slice, and <code>window</code> indicates a portion of the 2D slice.</p><p>Important: volume slices are always defined with respect to a given orientation of the 3D object.</p></div></section></article><article class="docstring"><header><a class="docstring-binding" id="UtilitiesForMRI.select-Union{Tuple{T}, Tuple{AbstractArray{T, 3}, VolumeSlice}} where T&lt;:Real" href="#UtilitiesForMRI.select-Union{Tuple{T}, Tuple{AbstractArray{T, 3}, VolumeSlice}} where T&lt;:Real"><code>UtilitiesForMRI.select</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">select(u::AbstractArray{T,3}, slice::VolumeSlice; orientation::Orientation=standard_orientation()) where {T&lt;:Real}</code></pre><p>Returns the specified 2D slice of a 3D image (according to a specified orientation)</p></div></section></article><article class="docstring"><header><a class="docstring-binding" id="UtilitiesForMRI.plot_volume_slices-Union{Tuple{AbstractArray{T, 3}}, Tuple{N}, Tuple{T}} where {T&lt;:Real, N}" href="#UtilitiesForMRI.plot_volume_slices-Union{Tuple{AbstractArray{T, 3}}, Tuple{N}, Tuple{T}} where {T&lt;:Real, N}"><code>UtilitiesForMRI.plot_volume_slices</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">plot_volume_slices(u::AbstractArray{T,3};
                   slices::Union{Nothing,NTuple{N,VolumeSlice}}=nothing,
                   spatial_geometry::Union{Nothing,CartesianSpatialGeometry{T}}=nothing,
                   cmap::String=&quot;gray&quot;,
                   vmin::Union{Nothing,Real}=nothing, vmax::Union{Nothing,Real}=nothing,
                   xlabel::Union{Nothing,AbstractString}=nothing, ylabel::Union{Nothing,AbstractString}=nothing,
                   cbar_label::Union{Nothing,AbstractString}=nothing,
                   title::Union{Nothing,AbstractString}=nothing,
                   savefile::Union{Nothing,String}=nothing,
                   orientation::Orientation=standard_orientation()) where {T&lt;:Real,N}</code></pre><p>Plot 2D slices of a given 3D image.</p></div></section></article></article><nav class="docs-footer"><a class="docs-footer-prevpage" href="../examples/">« Getting started</a><div class="flexbox-break"></div><p class="footer-message">Powered by <a href="https://github.com/JuliaDocs/Documenter.jl">Documenter.jl</a> and the <a href="https://julialang.org/">Julia Programming Language</a>.</p></nav></div><div class="modal" id="documenter-settings"><div class="modal-background"></div><div class="modal-card"><header class="modal-card-head"><p class="modal-card-title">Settings</p><button class="delete"></button></header><section class="modal-card-body"><p><label class="label">Theme</label><div class="select"><select id="documenter-themepicker"><option value="documenter-light">documenter-light</option><option value="documenter-dark">documenter-dark</option></select></div></p><hr/><p>This document was generated with <a href="https://github.com/JuliaDocs/Documenter.jl">Documenter.jl</a> version 0.27.24 on <span class="colophon-date" title="Friday 3 March 2023 15:01">Friday 3 March 2023</span>. Using Julia version 1.8.5.</p></section><footer class="modal-card-foot"></footer></div></div></div></body></html>
